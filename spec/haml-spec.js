// Generated by CoffeeScript 1.11.1
(function() {
  var isIe7or8;

  isIe7or8 = function() {
    var re, result, ua;
    result = false;
    if (navigator.appName === 'Microsoft Internet Explorer') {
      ua = navigator.userAgent;
      re = new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})");
      if (re.exec(ua) !== null) {
        result = parseFloat(RegExp.$1) < 9.0;
      }
    }
    return result;
  };

  beforeEach(function() {
    haml.cache = {};
    return this.addMatchers({
      toThrowContaining: function(expected) {
        var e, exception, isnot, ref, result;
        result = false;
        if (typeof this.actual !== 'function') {
          throw new Error('Actual is not a function');
        }
        try {
          this.actual();
        } catch (error) {
          e = error;
          exception = e;
        }
        if (exception != null) {
          result = exception.toString().indexOf(expected) >= 0;
        }
        isnot = (ref = this.isNot) != null ? ref : {
          "not ": ""
        };
        this.message = function() {
          if (exception) {
            return ["Expected function " + isnot + "to throw something with ", expected, ", but it threw", exception].join(' ');
          } else {
            return "Expected function to throw an exception.";
          }
        };
        return result;
      }
    });
  });

  describe('haml', function() {
    describe('empty template', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/haml-template" id="empty"></script>');
      });
      it('should return an empty string', function() {
        return expect(haml.compileHaml('empty')()).toEqual('');
      });
      it('should return an empty string from empty string', function() {
        return expect(haml.compileStringToJs('')()).toEqual('');
      });
      it('with coffescript should return an empty string', function() {
        return expect(haml.compileCoffeeHaml('empty')()).toEqual('');
      });
      return it('with coffescript string should return an empty string', function() {
        return expect(haml.compileCoffeeHamlFromString('')()).toEqual('');
      });
    });
    describe('simple template', function() {
      var generator, i, len, ref, results;
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="simple">\n' + '%h1\n' + '  %div\n' + '    %p\n' + '    %span</script>');
      });
      ref = ['javascript', 'productionjavascript'];
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        generator = ref[i];
        results.push((function(generator) {
          return it('should render the correct html for ' + generator, function() {
            var html;
            html = haml.compileHaml({
              sourceId: 'simple',
              generator: generator
            })();
            return expect(html).toEqual('\n' + '<h1>\n' + '  <div>\n' + '    <p>\n' + '    </p>\n' + '    <span>\n' + '    </span>\n' + '  </div>\n' + '</h1>\n');
          });
        })(generator));
      }
      return results;
    });
    describe('invalid template', function() {
      var generator, i, len, ref, results;
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="invalid">%h1\n' + '  %h2\n' + '    %h3{%h3 %h4}\n' + '      %h4\n' + '        %h5</script>' + '<script type="text/template" id="invalid2">%h1\n' + '  %h2\n' + '    %h3{id: "test", class: "test-class"\n' + '      %h4\n' + '        %h5</script>' + '<script type="text/template" id="invalid3">' + '%a#back(href="#" class="button back)\n' + '%span Back\n' + '%a#continue(href="#" class="button continue")\n' + '%span Save and Continue\n' + '</script>');
      });
      ref = ['javascript', 'productionjavascript'];
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        generator = ref[i];
        results.push((function(generator) {
          return it('should provide a meaningful message for ' + generator, function() {
            var line;
            line = isIe7or8() ? '4' : '3';
            expect(function() {
              return haml.compileHaml({
                sourceId: 'invalid',
                generator: generator
              })();
            }).toThrowContaining((function() {
              switch (generator) {
                case 'productionjavascript':
                  return 'Incorrect embedded code has resulted in an invalid Haml function';
                default:
                  return 'at line ' + line + ' and character 16:\n' + '    %h3{%h3 %h4}\n' + '---------------^';
              }
            })());
            expect(function() {
              return haml.compileHaml({
                sourceId: 'invalid2',
                generator: generator
              });
            }).toThrowContaining('at line ' + line + ' and character 8:\n' + '    %h3{id: "test", class: "test-class"\n' + '-------^');
            return expect(function() {
              return haml.compileHaml({
                sourceId: 'invalid3',
                generator: generator
              });
            }).toThrowContaining('Expected a quoted string or an identifier for the attribute value');
          });
        })(generator));
      }
      return results;
    });
    describe('simple template with text', function() {
      var fn, generator, i, len, ref;
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="simple">\n' + '%h1\n' + '  %div\n' + '    %p This is "some" text\n' + '      This is "some" text\n' + '    This is some <div> text\n' + '    \\%span\n' + '    %span %h1 %h1 %h1</script>');
      });
      ref = ['javascript', 'productionjavascript'];
      fn = function(generator) {
        return it('should render the correct html for ' + generator, function() {
          var html;
          html = haml.compileHaml({
            sourceId: 'simple',
            generator: generator
          })();
          return expect(html).toEqual('\n' + '<h1>\n' + '  <div>\n' + '    <p>\n' + '      This is "some" text\n' + '      This is "some" text\n' + '    </p>\n' + '    This is some <div> text\n' + '    %span\n' + '    <span>\n' + '      %h1 %h1 %h1\n' + '    </span>\n' + '  </div>\n' + '</h1>\n');
        });
      };
      for (i = 0, len = ref.length; i < len; i++) {
        generator = ref[i];
        fn(generator);
      }
      return it('should render the correct html with coffeescript', function() {
        var html;
        html = haml.compileCoffeeHaml('simple')();
        return expect(html).toEqual('\n' + '<h1>\n' + '  <div>\n' + '    <p>\n' + '      This is "some" text\n' + '      This is "some" text\n' + '    </p>\n' + '    This is some <div> text\n' + '    %span\n' + '    <span>\n' + '      %h1 %h1 %h1\n' + '    </span>\n' + '  </div>\n' + '</h1>\n');
      });
    });
    describe('template with {} attributes', function() {
      var fn, generator, i, len, ref;
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="attributes">\n' + '%h1\n' + '  %div{id: "test"}\n' + '    %p{id: \'test2\', ' + '        class: "blah", name: null, test: false, checked: false, selected: true} This is some text\n' + '      This is some text\n' + '    This is some div text\n' + '    %label(for = "a"){for: ["b", "c"]}/\n' + '    %div{id: [\'test\', 1], class: [model.name, "class2"], for: "something"}\n' + '</script>\n' + '<script type="text/template" id="coffee-attributes">\n' + '%h1\n' + '  %div{id: "test"}\n' + '    %p{id: \'test2\', ' + '        class: "blah", name: null, test: false, checked: false, selected: true} This is some text\n' + '      This is some text\n' + '    This is some div text\n' + '    %label(for = "a"){for: ["b", "c"]}/\n' + '    %div{id: [\'test\', 1], class: [@model.name, "class2"], for: "something"}\n' + '</script>');
      });
      ref = ['javascript', 'productionjavascript'];
      fn = function(generator) {
        return it('should render the correct html for ' + generator, function() {
          var html;
          html = haml.compileHaml({
            sourceId: 'attributes',
            generator: generator
          })({
            model: {
              name: 'class1'
            }
          });
          return expect(html).toEqual('\n' + '<h1>\n' + '  <div id="test">\n' + '    <p id="test2" class="blah" selected="selected">\n' + '      This is some text\n' + '      This is some text\n' + '    </p>\n' + '    This is some div text\n' + '    <label for="a-b-c"/>\n' + '    <div id="test-1" class="class1 class2" for="something">\n' + '    </div>\n' + '  </div>\n' + '</h1>\n');
        });
      };
      for (i = 0, len = ref.length; i < len; i++) {
        generator = ref[i];
        fn(generator);
      }
      return it('with coffescript should render the correct html', function() {
        var html;
        html = haml.compileCoffeeHaml('coffee-attributes').call({
          model: {
            name: 'class1'
          }
        });
        return expect(html).toEqual('\n' + '<h1>\n' + '  <div id="test">\n' + '    <p id="test2" class="blah" selected="selected">\n' + '      This is some text\n' + '      This is some text\n' + '    </p>\n' + '    This is some div text\n' + '    <label for="a-b-c"/>\n' + '    <div id="test-1" class="class1 class2" for="something">\n' + '    </div>\n' + '  </div>\n' + '</h1>\n');
      });
    });
    describe('template with () attributes', function() {
      var generator, i, len, ref, results;
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="attributes">\n' + '%h1\n' + '  %div(id = "test")\n' + '    %p(id=test2 class="blah"\n selected="selected") This is some text\n' + '      This is some text\n' + '    This is some div text\n' + '    %div(id=test){id: 1, class: [model.name, "class2"]}\n' + '    %a(href="#" data-key="MOD_DESC")/' + '</script>');
      });
      ref = ['javascript', 'productionjavascript'];
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        generator = ref[i];
        results.push((function(generator) {
          return it('should render the correct html for ' + generator, function() {
            var html;
            html = haml.compileHaml({
              sourceId: 'attributes',
              generator: generator
            })({
              model: {
                name: 'class1'
              }
            });
            return expect(html).toEqual('\n' + '<h1>\n' + '  <div id="test">\n' + '    <p id="test2" class="blah" selected="selected">\n' + '      This is some text\n' + '      This is some text\n' + '    </p>\n' + '    This is some div text\n' + '    <div id="test-1" class="class1 class2">\n' + '    </div>\n' + '    <a href="#" data-key="MOD_DESC"/>\n' + '  </div>\n' + '</h1>\n');
          });
        })(generator));
      }
      return results;
    });
    describe('template with id and class selectors', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="attributes">\n' + '%h1\n' + '  #test.test\n' + '    %p#test.blah{id: 2, class: "test"} This is some text\n' + '      This is some text\n' + '    This is some div text\n' + '    .class1.class2/\n' + '</script>');
      });
      return it('should render the correct html', function() {
        var html;
        html = haml.compileHaml('attributes')();
        return expect(html).toEqual('\n' + '<h1>\n' + '  <div id="test" class="test">\n' + '    <p id="test-2" class="blah test">\n' + '      This is some text\n' + '      This is some text\n' + '    </p>\n' + '    This is some div text\n' + '    <div class="class1 class2"/>\n' + '  </div>\n' + '</h1>\n');
      });
    });
    describe('template with self-closing tags', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="self-closing-tags">\n' + '%div\n' + '  meta, img, link, script, br, and hr\n' + '  %meta\n' + '  %meta/\n' + '  %meta\n' + '    meta\n' + '  %img\n' + '  %img/\n' + '  %img\n' + '    img\n' + '  %link\n' + '  %link/\n' + '  %link\n' + '    link\n' + '  %br\n' + '  %br/\n' + '  %br\n' + '    br/\n' + '  %hr\n' + '  %hr/\n' + '  %hr\n' + '    hr\n' + '  %div/\n' + '  %p/\n' + '</script>');
      });
      return it('should render the correct html', function() {
        var html;
        html = haml.compileHaml('self-closing-tags')({});
        return expect(html).toEqual('\n' + '<div>\n' + '  meta, img, link, script, br, and hr\n' + '  <meta/>\n' + '  <meta/>\n' + '  <meta>\n' + '    meta\n' + '  </meta>\n' + '  <img/>\n' + '  <img/>\n' + '  <img>\n' + '    img\n' + '  </img>\n' + '  <link/>\n' + '  <link/>\n' + '  <link>\n' + '    link\n' + '  </link>\n' + '  <br/>\n' + '  <br/>\n' + '  <br>\n' + '    br/\n' + '  </br>\n' + '  <hr/>\n' + '  <hr/>\n' + '  <hr>\n' + '    hr\n' + '  </hr>\n' + '  <div/>\n' + '  <p/>\n' + '</div>\n');
      });
    });
    describe('template with unescaped HTML', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="unescaped">' + '%h1 !<div>\n' + '  !#test.test\n' + '    !%p#test.blah{id: 2, class: "test"} This is some text\n' + '      !This is some text\n' + '!    This is some <div> text\n' + '!    <div class="class1 class2"></div>\n' + '</script>');
      });
      return it('should render the correct html', function() {
        var html;
        html = haml.compileHaml('unescaped')();
        return expect(html).toEqual('<h1>\n' + '  <div>\n' + '  #test.test\n' + '    %p#test.blah{id: 2, class: "test"} This is some text\n' + '      This is some text\n' + '    This is some <div> text\n' + '    <div class="class1 class2"></div>\n' + '</h1>\n');
      });
    });
    describe('template with Javascript evaluation', function() {
      var generator, i, len, ref, results;
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="evaluation">\n' + '.box.error\n' + '  %span\n' + '    = errorTitle\n' + '  .clear\n' + '    - var label = "Calculation: ";\n' + '    %span= errorHeading\n' + '    = label + (1 + 2 * 3)\n' + '    = ["hi", "there", "reader!"]\n' + '    = evilScript \n' + '    %span&= errorHeading\n' + '    &= label + (1 + 2 * 3)\n' + '    &= ["hi", "there", "reader!"]\n' + '    &= evilScript \n' + '    %span!= errorHeading\n' + '    != label + (1 + 2 * 3)\n' + '    != ["hi", "there", "reader!"]\n' + '    != evilScript \n' + '</script>');
      });
      ref = ['javascript', 'productionjavascript'];
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        generator = ref[i];
        results.push((function(generator) {
          return it('should render the correct html for ' + generator, function() {
            var html;
            html = haml.compileHaml({
              sourceId: 'evaluation',
              generator: generator
            })({
              errorTitle: "Error Title",
              errorHeading: "Error Heading <div>div text</div>",
              evilScript: '<script>alert("I\'m evil!");</script>'
            });
            return expect(html).toEqual('\n' + '<div class="box error">\n' + '  <span>\n' + '    Error Title\n' + '  </span>\n' + '  <div class="clear">\n' + '    <span>\n' + '      Error Heading &lt;div&gt;div text&lt;/div&gt;\n' + '    </span>\n' + '    Calculation: 7\n' + '    hi,there,reader!\n' + '    &lt;script&gt;alert(&quot;I&#39;m evil!&quot;);&lt;/script&gt;\n' + '    <span>\n' + '      Error Heading &lt;div&gt;div text&lt;/div&gt;\n' + '    </span>\n' + '    Calculation: 7\n' + '    hi,there,reader!\n' + '    &lt;script&gt;alert(&quot;I&#39;m evil!&quot;);&lt;/script&gt;\n' + '    <span>\n' + '      Error Heading <div>div text</div>\n' + '    </span>\n' + '    Calculation: 7\n' + '    hi,there,reader!\n' + '    <script>alert("I\'m evil!");</script>\n' + '  </div>\n' + '</div>\n');
          });
        })(generator));
      }
      return results;
    });
    describe('template with Coffee evaluation', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="evaluation">\n' + '.box.error\n' + '  %span\n' + '    = @errorTitle\n' + '  .clear\n' + '    %span= @errorHeading\n' + '    = label = "Calculation: "; label + (1 + 2 * 3)\n' + '    = ["hi", "there", "reader!"]\n' + '    = @evilScript \n' + '    %span&= @errorHeading\n' + '    &= label = "Calculation: "; label + (1 + 2 * 3)\n' + '    &= ["hi", "there", "reader!"]\n' + '    &= @evilScript \n' + '    %span!= @errorHeading\n' + '    != label = "Calculation: "; label + (1 + 2 * 3)\n' + '    != ["hi", "there", "reader!"]\n' + '    != @evilScript \n' + '</script>');
      });
      return it('should render the correct html', function() {
        var html;
        html = haml.compileCoffeeHaml('evaluation').call({
          errorTitle: "Error Title",
          errorHeading: "Error Heading <div>div text</div>",
          evilScript: '<script>alert("I\'m evil!");</script>'
        });
        return expect(html).toEqual('\n<div class="box error">\n' + '  <span>\n' + '    Error Title\n' + '  </span>\n' + '  <div class="clear">\n' + '    <span>\n' + '      Error Heading &lt;div&gt;div text&lt;/div&gt;\n' + '    </span>\n' + '    Calculation: 7\n' + '    hi,there,reader!\n' + '    &lt;script&gt;alert(&quot;I&#39;m evil!&quot;);&lt;/script&gt;\n' + '    <span>\n' + '      Error Heading &lt;div&gt;div text&lt;/div&gt;\n' + '    </span>\n' + '    Calculation: 7\n' + '    hi,there,reader!\n' + '    &lt;script&gt;alert(&quot;I&#39;m evil!&quot;);&lt;/script&gt;\n' + '    <span>\n' + '      Error Heading <div>div text</div>\n' + '    </span>\n' + '    Calculation: 7\n' + '    hi,there,reader!\n' + '    <script>alert("I\'m evil!");</script>\n' + '  </div>\n' + '</div>\n');
      });
    });
    describe('template with Javascript code lines', function() {
      var generator, i, len, ref, results;
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="evaluation">\n' + '.main\n' + '  - var foo = "hello";\n' + '  - foo += " world";\n' + '  %span\n' + '    = foo\n' + '</script>\n' + '<script type="text/template" id="evaluation-with-loops">\n' + '.main\n' + '  - _(["Option 1", "Option 2", "Option 3"]).each(function (option) {\n' + '    %span= option\n' + '  - });\n' + '  - for (var i = 0; i < 5; i++) {\n' + '    %p= i\n' + '  - }\n' + '</script>' + '<script type="text/template" id="evaluation-using-context">\n' + '.main\n' + '  - var foo = model.foo;\n' + '  - foo += " world";\n' + '  %span\n' + '    = foo\n' + '</script>' + '<script type="text/template" id="attribute-hash-evaluation-using-outer-scope">\n' + '.main\n' + '  - var foo = "hello world";\n' + '  %span{someattribute: foo}\n' + '</script>');
      });
      ref = ['javascript', 'productionjavascript'];
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        generator = ref[i];
        results.push((function(generator) {
          it('should render the correct html using locally defined variables for ' + generator, function() {
            var html;
            html = haml.compileHaml({
              sourceId: 'evaluation',
              generator: generator
            })();
            return expect(html).toEqual('\n<div class="main">\n' + '  <span>\n' + '    hello world\n' + '  </span>\n' + '</div>\n');
          });
          it('should render the correct html when the template has loops for ' + generator, function() {
            var html;
            html = haml.compileHaml('evaluation-with-loops', {
              generator: generator
            })();
            return expect(html).toEqual('\n<div class="main">\n' + '    <span>\n' + '      Option 1\n' + '    </span>\n' + '    <span>\n' + '      Option 2\n' + '    </span>\n' + '    <span>\n' + '      Option 3\n' + '    </span>\n' + '    <p>\n' + '      0\n' + '    </p>\n' + '    <p>\n' + '      1\n' + '    </p>\n' + '    <p>\n' + '      2\n' + '    </p>\n' + '    <p>\n' + '      3\n' + '    </p>\n' + '    <p>\n' + '      4\n' + '    </p>\n' + '</div>\n');
          });
          it('should provide access to the context within inline javascript for ' + generator, function() {
            var html, model;
            model = {
              foo: "hello"
            };
            html = haml.compileHaml({
              sourceId: 'evaluation-using-context',
              generator: generator
            }).call(null, {
              model: model
            });
            return expect(html).toEqual('\n<div class="main">\n' + '  <span>\n' + '    hello world\n' + '  </span>\n' + '</div>\n');
          });
          return it('should be able to access variables declared as part of the haml for ' + generator, function() {
            var html, model;
            model = {
              foo: "hello"
            };
            html = haml.compileHaml({
              sourceId: 'attribute-hash-evaluation-using-outer-scope',
              generator: generator
            }).call(null, {
              model: model
            });
            return expect(html).toEqual('\n<div class="main">\n' + '  <span someattribute="hello world">\n' + '  </span>\n' + '</div>\n');
          });
        })(generator));
      }
      return results;
    });
    describe('template with Coffeescript code lines', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="evaluation">\n' + '.main\n' + '  - foo = "hello"\n' + '  - foo += " world"\n' + '  %span\n' + '    %span/\n' + '      %span/\n' + '    = foo\n' + '</script>\n' + '<script type="text/template" id="evaluation-with-loops">\n' + '.main\n' + '  - for option in ["Option 1", "Option 2", "Option 3"]\n' + '    %span= option\n' + '  - for i in [0...5]\n' + '    %p= i\n' + '</script>' + '<script type="text/template" id="evaluation-using-context">\n' + '.main\n' + '  - foo = @model.foo\n' + '  - foo += " world"\n' + '  %span\n' + '    = foo\n' + '</script>' + '<script type="text/template" id="attribute-hash-evaluation-using-outer-scope">\n' + '.main\n' + '  - foo = "hello world"\n' + '  %span{someattribute: foo}\n' + '</script>');
      });
      it('should render the correct html using locally defined variables', function() {
        var html;
        html = haml.compileCoffeeHaml('evaluation')();
        return expect(html).toEqual('\n<div class="main">\n' + '  <span>\n' + '    <span/>\n' + '      <span/>\n' + '    hello world\n' + '  </span>\n' + '</div>\n');
      });
      it('should render the correct html when the template has loops', function() {
        var html;
        html = haml.compileCoffeeHaml('evaluation-with-loops')();
        return expect(html).toEqual('\n<div class="main">\n' + '    <span>\n' + '      Option 1\n' + '    </span>\n' + '    <span>\n' + '      Option 2\n' + '    </span>\n' + '    <span>\n' + '      Option 3\n' + '    </span>\n' + '    <p>\n' + '      0\n' + '    </p>\n' + '    <p>\n' + '      1\n' + '    </p>\n' + '    <p>\n' + '      2\n' + '    </p>\n' + '    <p>\n' + '      3\n' + '    </p>\n' + '    <p>\n' + '      4\n' + '    </p>\n' + '</div>\n');
      });
      it('should provide access to the context within inline javascript', function() {
        var html, model;
        model = {
          foo: "hello"
        };
        html = haml.compileCoffeeHaml('evaluation-using-context').call({
          model: model
        });
        return expect(html).toEqual('\n<div class="main">\n' + '  <span>\n' + '    hello world\n' + '  </span>\n' + '</div>\n');
      });
      return it('should be able to access variables declared as part of the haml', function() {
        var html, model;
        model = {
          foo: "hello"
        };
        html = haml.compileCoffeeHaml('attribute-hash-evaluation-using-outer-scope').call({
          model: model
        });
        return expect(html).toEqual('\n<div class="main">\n' + '  <span someattribute="hello world">\n' + '  </span>\n' + '</div>\n');
      });
    });
    describe('template with comments', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="comments">\n' + '.main\n' + '  / This is a comment\n' + '  /\n' + '    %span\n' + '      = errorTitle\n' + '  -# .clear\n' + '      %span= errorHeading\n' + '  -#  = var label = "Calculation: "; return label + (1 + 2 * 3)\n' + '  -#  = ["hi", "there", "reader!"]\n' + '  -#  = evilScript \n' + '  /[if IE]  \n' + '    %a(href = "http://www.mozilla.com/en-US/firefox/" )\n' + '      %h1 Get Firefox\n' + '</script>');
      });
      return it('should render the correct html', function() {
        var html;
        html = haml.compileHaml('comments')({
          errorTitle: "An error's a terrible thing"
        });
        return expect(html).toEqual('\n<div class="main">\n' + '  <!-- This is a comment  -->\n' + '  <!--\n' + '    <span>\n' + '      An error&#39;s a terrible thing\n' + '    </span>\n' + '  -->\n' + '  <!--[if IE]  >\n' + '    <a href="http://www.mozilla.com/en-US/firefox/">\n' + '      <h1>\n' + '        Get Firefox\n' + '      </h1>\n' + '    </a>\n' + '  <![endif]-->\n' + '</div>\n');
      });
    });
    describe('template with Javascript code lines and no closing blocks', function() {
      var generator, i, len, ref, results;
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="evaluation-with-loops">\n' + '.main\n' + '  - _(["Option 1", "Option 2", "Option 3"]).each(function (option) {\n' + '    %span= option\n' + '  - for (var i = 0; i < 5; i++) {\n' + '    %p= i\n' + '</script>');
      });
      ref = ['javascript', 'productionjavascript'];
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        generator = ref[i];
        results.push((function(generator) {
          return it('should render the correct html when the template has loops for ' + generator, function() {
            var html;
            html = haml.compileHaml({
              sourceId: 'evaluation-with-loops',
              generator: generator
            })();
            return expect(html).toEqual('\n<div class="main">\n' + '    <span>\n' + '      Option 1\n' + '    </span>\n' + '    <span>\n' + '      Option 2\n' + '    </span>\n' + '    <span>\n' + '      Option 3\n' + '    </span>\n' + '    <p>\n' + '      0\n' + '    </p>\n' + '    <p>\n' + '      1\n' + '    </p>\n' + '    <p>\n' + '      2\n' + '    </p>\n' + '    <p>\n' + '      3\n' + '    </p>\n' + '    <p>\n' + '      4\n' + '    </p>\n' + '</div>\n');
          });
        })(generator));
      }
      return results;
    });
    describe('Escaping HTML', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="simple">' + '.main\n' + '  <div>\n' + '    &  <p>\n' + '    &  </p>\n' + '    &  <span>\n' + '    &    <script>alert("I\'m evil!");\n' + '    &  </span>\n' + '  </div>\n' + '</script>');
      });
      return it('should render the correct html', function() {
        var html;
        html = haml.compileHaml('simple')();
        return expect(html).toEqual('<div class="main">\n' + '  <div>\n' + '      &lt;p&gt;\n' + '      &lt;/p&gt;\n' + '      &lt;span&gt;\n' + '        &lt;script&gt;alert(&quot;I&#39;m evil!&quot;);\n' + '      &lt;/span&gt;\n' + '  </div>\n' + '</div>\n');
      });
    });
    describe('Whitespace Removal: > and <', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="whitespace-removal">\n' + '%blockquote<\n' + '  %div\n' + '    Foo!\n' + '%img\n' + '%img>\n' + '%img\n' + '%p<= "Foo\\nBar"\n' + '%img\n' + '%pre><\n' + '  foo\n' + '  bar\n' + '%img\n' + '</script>');
      });
      return it('should render the correct html', function() {
        var html;
        html = haml.compileHaml('whitespace-removal')();
        return expect(html).toEqual('\n<blockquote><div>\n' + '    Foo!\n' + '  </div></blockquote>\n' + '<img/><img/><img/>\n' + '<p>Foo\n' + 'Bar</p>\n' + '<img/><pre>foo\n' + 'bar</pre><img/>\n');
      });
    });
    describe('template with object reference', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="object-reference">\n' + '%h1\n' + '  %div[test]\n' + '    %p[test2] This is some text\n' + '      This is some text\n' + '    This is some div text\n' + '    .class1[test3]{id: 1, class: "class3", for: "something"}\n' + '</script>');
      });
      return it('should render the correct html', function() {
        var html;
        html = haml.compileHaml('object-reference')({
          test: {
            id: 'test'
          },
          test2: {
            id: 'test2',
            'class': 'blah'
          },
          test3: {
            attributes: {
              id: 'test',
              'class': 'class2'
            },
            get: function(name) {
              return this.attributes[name];
            }
          }
        });
        return expect(html).toEqual('\n<h1>\n' + '  <div id="test">\n' + '    <p id="test2" class="blah">\n' + '      This is some text\n' + '      This is some text\n' + '    </p>\n' + '    This is some div text\n' + '    <div class="class1 class2 class3" id="test-1" for="something">\n' + '    </div>\n' + '  </div>\n' + '</h1>\n');
      });
    });
    describe('coffescript template with object reference', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="object-reference">\n' + '%h1\n' + '  %div[@test]\n' + '    %p[@test2] This is some text\n' + '      This is some text\n' + '    This is some div text\n' + '    .class1[@test3]{id: 1, class: "class3", for: "something"}\n' + '</script>');
      });
      return it('should render the correct html', function() {
        var html;
        html = haml.compileCoffeeHaml('object-reference').call({
          test: {
            id: 'test'
          },
          test2: {
            id: 'test2',
            'class': 'blah'
          },
          test3: {
            attributes: {
              id: 'test',
              'class': 'class2'
            },
            get: function(name) {
              return this.attributes[name];
            }
          }
        });
        return expect(html).toEqual('\n<h1>\n' + '  <div id="test">\n' + '    <p id="test2" class="blah">\n' + '      This is some text\n' + '      This is some text\n' + '    </p>\n' + '    This is some div text\n' + '    <div class="class1 class2 class3" id="test-1" for="something">\n' + '    </div>\n' + '  </div>\n' + '</h1>\n');
      });
    });
    describe('html 5 data attributes', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="html5-attributes">\n' + '%h1\n' + '  %div{id: "test"}\n' + '    %p{id: \'test2\', data: {\n' + '        class: "blah", name: null, test: false, checked: false, selected: true}} This is some text\n' + '</script>');
      });
      return it('should render the correct html', function() {
        var html;
        html = haml.compileHaml('html5-attributes')();
        return expect(html).toEqual('\n<h1>\n' + '  <div id="test">\n' + '    <p id="test2" data-class="blah" data-selected="true">\n' + '      This is some text\n' + '    </p>\n' + '  </div>\n' + '</h1>\n');
      });
    });
    describe('without template', function() {
      return it('should render the correct html', function() {
        return expect(haml.compileStringToJs("%div")()).toEqual('<div>\n</div>\n');
      });
    });
    describe('whitespace preservation', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="whitespace-preservation">\n' + '%h1\n' + '  %div\n' + '    ~ "Foo\\n<pre>Bar\\nBaz</pre>\\n<a>Test\\nTest\\n</a>\\nOther"\n' + '</script>');
      });
      return it('should render the correct html', function() {
        var html;
        html = haml.compileHaml('whitespace-preservation')();
        return expect(html).toEqual('\n<h1>\n' + '  <div>\n' + '    Foo\n' + '<pre>Bar&#x000A;Baz</pre>\n' + '<a>Test&#x000A;Test&#x000A;</a>\n' + 'Other\n' + '  </div>\n' + '</h1>\n');
      });
    });
    describe('doctype', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="doctype">\n' + '!!! XML\n' + '!!! XML iso-8859-1\n' + '!!!\n' + '!!! 1.1\n' + '%html\n' + '</script>');
      });
      return it('should render the correct html', function() {
        var html;
        html = haml.compileHaml('doctype')();
        return expect(html).toEqual('\n<?xml version=\'1.0\' encoding=\'utf-8\' ?>\n' + '<?xml version=\'1.0\' encoding=\'iso-8859-1\' ?>\n' + '<!DOCTYPE html>\n' + '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">\n' + '<html>\n</html>\n');
      });
    });
    return describe('Multiline code blocks', function() {
      var generator, i, len, ref;
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="multiline">\n' + '%whoo\n' + '  %hoo=                           |\n' + '    "I think this might get " +   |\n' + '    "pretty long so I should " +  |\n' + '    "probably make it " +         |\n' + '    "multiline so it doesn\'t " + |\n' + '    "look awful."                 |\n' + '  %p This is short.\n' + '</script>');
      });
      ref = ['javascript', 'productionjavascript'];
      for (i = 0, len = ref.length; i < len; i++) {
        generator = ref[i];
        it('should render the correct html for ' + generator, function() {
          var html;
          html = haml.compileHaml('multiline', {
            generator: generator
          })();
          return expect(html).toEqual('\n<whoo>\n' + '  <hoo>\n' + '    I think this might get pretty long so I should probably make it multiline so it doesn&#39;t look awful.\n' + '  </hoo>\n' + '  <p>\n' + '    This is short.\n' + '  </p>\n' + '</whoo>\n');
        });
      }
      return it('with coffescript should render the correct html', function() {
        var html;
        html = haml.compileCoffeeHaml('multiline')();
        return expect(html).toEqual('\n<whoo>\n' + '  <hoo>\n' + '    I think this might get pretty long so I should probably make it multiline so it doesn&#39;t look awful.\n' + '  </hoo>\n' + '  <p>\n' + '    This is short.\n' + '  </p>\n' + '</whoo>\n');
      });
    });
  });

  describe('filters', function() {
    beforeEach(function() {
      return setFixtures('<script type="text/template" id="plain-filter">\n%h1\n  %p\n    :plain\n      Does not parse the filtered text. This is useful for large blocks of text without HTML tags,\n      when you don\'t want lines starting with . or - to be parsed.\n  %span Other Contents\n</script>');
    });
    it('should render the result of the filter function', function() {
      var html;
      html = haml.compileHaml('plain-filter')();
      return expect(html).toEqual('\n<h1>\n  <p>\n    Does not parse the filtered text. This is useful for large blocks of text without HTML tags,\n    when you don\'t want lines starting with . or - to be parsed.\n  </p>\n  <span>\n    Other Contents\n  </span>\n</h1>\n');
    });
    it('should raise an error if the filter is not found', function() {
      return expect(function() {
        return haml.compileStringToJs('%p\n  :unknown\n    blah di blah di blah');
      }).toThrow('Filter \'unknown\' not registered. Filter functions need to be added to \'haml.filters\'. at line 2 and character 10:\n  :unknown\n---------^');
    });
    it('generates javascript filter blocks correctly', function() {
      return expect(haml.compileCoffeeHamlFromString('%body\n  :javascript\n    // blah di blah di blah\n    function () {\n      return \'blah\';\n    }')()).toEqual('<body>\n  <script type="text/javascript">\n    //<![CDATA[\n      // blah di blah di blah\n      function () {\n        return \'blah\';\n      }\n    //]]>\n  </script>\n</body>\n');
    });
    it('generates css filter blocks correctly', function() {
      return expect(haml.compileStringToJs('%head\n  :css\n    /* blah di blah di blah */\n    .body {\n      color: red;\n    }')()).toEqual('<head>\n  <style type="text/css">\n    /*<![CDATA[*/\n      /* blah di blah di blah */\n      .body {\n        color: red;\n      }\n    /*]]>*/\n  </style>\n</head>\n');
    });
    it('generates CDATA filter blocks correctly', function() {
      return expect(haml.compileStringToJs('%body\n  :cdata\n    // blah di blah di blah\n    function () {\n      return \'blah\';\n    }')()).toEqual('<body>\n  <![CDATA[\n    // blah di blah di blah\n    function () {\n      return \'blah\';\n    }\n  ]]>\n</body>\n');
    });
    it('generates preserve filter blocks correctly', function() {
      return expect(haml.compileStringToJs('%p\n  :preserve\n    Foo\n    <pre>Bar\n    Baz</pre>\n    <a>Test\n    Test\n    </a>\n    Other')()).toEqual('<p>\n  Foo&#x000A; <pre>Bar&#x000A; Baz</pre>&#x000A; <a>Test&#x000A; Test&#x000A; </a>&#x000A; Other\n</p>\n');
    });
    it('generates escape filter blocks correctly', function() {
      return expect(haml.compileStringToJs('%p\n  :escaped\n    Foo\n    <pre>\'Bar\'\n    Baz</pre>\n    <a>Test\n    Test\n    </a>\n    Other&')()).toEqual('<p>\n  Foo\n  &lt;pre&gt;&#39;Bar&#39;\n  Baz&lt;/pre&gt;\n  &lt;a&gt;Test\n  Test\n  &lt;/a&gt;\n  Other&amp;\n</p>\n');
    });
    it('handles large blocks of text with escaped interpolate markers correctly', function() {
      var expected, hamlSource;
      hamlSource = '%h1 Why would I use it?\n.contents\n  %div\n    Sinatra webapp\n    %pre(class="brush: ruby")\n      :plain\n        post \'/contract_proposals\' do\n          begin\n            contract_attributes = JSON.parse(request.body.read)[\'contract\']\n            contract = ContractFactory.contract_from contract_attributes\n\n            if contract.valid?\n              contract.generate_pdf(File.join(settings.public_folder, PDF_SUBDIR))\n              logger.info %{action=contract_created_from_condor, account_manager="\\#{contract.account_manager.name}", agent_code=\\#{contract.agency.agent_code}}\n              return [201, contract.to_json(request.base_url)]\n            else\n              logger.error %{action=create_contract_proposal_failure, error_message="\\#{contract.validation_errors}"}\n              logger.error contract_attributes.to_json\n              return [400, {errors: contract.validation_errors}.to_json]\n            end\n          rescue Exception => e\n            request.body.rewind\n            logger.error %{action=create_contract_proposal_failure, error_message="\\#{e}"}\n            logger.error request.body.read\n            logger.error e\n            return [400, "Sorry, but I couldn\'t generate your contract proposal!"]\n          end\n        end\n\n        options \'/contract_proposals\' do\n          headers[\'Access-Control-Allow-Methods\'] = \'POST, OPTIONS\'\n          headers[\'Access-Control-Allow-Headers\'] = \'X-Requested-With, Content-Type\'\n        end';
      expected = '<h1>\n  Why would I use it?\n</h1>\n<div class="contents">\n  <div>\n    Sinatra webapp\n    <pre class="brush: ruby">\n      post \'/contract_proposals\' do\n        begin\n          contract_attributes = JSON.parse(request.body.read)[\'contract\']\n          contract = ContractFactory.contract_from contract_attributes\n\n\n            if contract.valid?\n              contract.generate_pdf(File.join(settings.public_folder, PDF_SUBDIR))\n              logger.info %{action=contract_created_from_condor, account_manager="#{contract.account_manager.name}", agent_code=#{contract.agency.agent_code}}\n              return [201, contract.to_json(request.base_url)]\n            else\n              logger.error %{action=create_contract_proposal_failure, error_message="#{contract.validation_errors}"}\n              logger.error contract_attributes.to_json\n              return [400, {errors: contract.validation_errors}.to_json]\n            end\n          rescue Exception => e\n            request.body.rewind\n            logger.error %{action=create_contract_proposal_failure, error_message="#{e}"}\n            logger.error request.body.read\n            logger.error e\n            return [400, "Sorry, but I couldn\'t generate your contract proposal!"]\n          end\n        end\n\n        options \'/contract_proposals\' do\n          headers[\'Access-Control-Allow-Methods\'] = \'POST, OPTIONS\'\n          headers[\'Access-Control-Allow-Headers\'] = \'X-Requested-With, Content-Type\'\n        end\n    </pre>\n  </div>\n</div>';
      return expect(_.str.trim(haml.compileHaml({
        source: hamlSource
      })())).toEqual(expected);
    });
    return it('handles large blocks of text correctly', function() {
      var expected, hamlSource;
      hamlSource = '%h1 Why would I use it?\n.contents\n  %div\n    Webmachine Resource\n    %pre\n      :escaped\n         def options\n           {\n             \'Access-Control-Allow-Methods\' => \'POST, OPTIONS\',\n             \'Access-Control-Allow-Headers\' => \'X-Requested-With, Content-Type\'\n           }\n         end\n          \n         def finish_request\n           response.headers[\'Access-Control-Allow-Origin\'] = \'*\'\n         end\n          \n         def allowed_methods\n           [\'GET\', \'HEAD\', \'POST\', \'OPTIONS\']\n         end\n          \n         def malformed_request?\n           puts "malformed_request?"\n           body = request.body.to_s\n           if body.nil?\n             false\n           else\n             begin\n               contract_attributes = JSON.parse(request.body.to_s)[\'contract\']\n               @contract = ContractFactory.contract_from contract_attributes\n               !@contract.valid?\n             rescue => e\n               true\n             end\n         end\n      %div';
      expected = '<h1>\n  Why would I use it?\n</h1>\n<div class="contents">\n  <div>\n    Webmachine Resource\n    <pre>\n       def options\n         {\n           &#39;Access-Control-Allow-Methods&#39; =&gt; &#39;POST, OPTIONS&#39;,\n           &#39;Access-Control-Allow-Headers&#39; =&gt; &#39;X-Requested-With, Content-Type&#39;\n         }\n       end\n        \n       def finish_request\n         response.headers[&#39;Access-Control-Allow-Origin&#39;] = &#39;*&#39;\n       end\n        \n       def allowed_methods\n         [&#39;GET&#39;, &#39;HEAD&#39;, &#39;POST&#39;, &#39;OPTIONS&#39;]\n       end\n        \n       def malformed_request?\n         puts &quot;malformed_request?&quot;\n         body = request.body.to_s\n         if body.nil?\n           false\n         else\n           begin\n             contract_attributes = JSON.parse(request.body.to_s)[&#39;contract&#39;]\n             @contract = ContractFactory.contract_from contract_attributes\n             !@contract.valid?\n           rescue =&gt; e\n             true\n           end\n       end\n      <div>\n      </div>\n    </pre>\n  </div>\n</div>';
      return expect(_.str.trim(haml.compileHaml({
        source: hamlSource
      })())).toEqual(expected);
    });
  });

  describe('interpolated text', function() {
    it('should allow code to be interpolated within plain text using #{}', function() {
      return expect(haml.compileStringToJs('%p This is #{quality} cake! #{"Yay!"}')({
        quality: 'scrumptious'
      })).toEqual('<p>\n  This is scrumptious cake! Yay!\n</p>\n');
    });
    it('should handle escaped markers', function() {
      return expect(haml.compileStringToJs('%p\n  Look at \\\\#{h(word)} lack of backslash: \\#{foo}\n  And yon presence thereof: \\{foo}')({
        h: (function(word) {
          return word.toLowerCase();
        }),
        word: 'YON'
      })).toEqual('<p>\n  Look at \\\\yon lack of backslash: #{foo}\n  And yon presence thereof: \\{foo}\n</p>\n');
    });
    it('generates filter blocks correctly', function() {
      return expect(haml.compileStringToJs('%body\n  :javascript\n    $(document).ready(function() {\n      alert("#{message}");\n    });\n  %p\n    :preserve\n      Foo\n      #{"<pre>Bar\\nBaz</pre>"}\n      <a>Test\n      Test\n      </a>\n      Other\n    :escaped\n      Foo\n      #{"<pre>\'Bar\'\\nBaz</pre>"}\n      <a>Test\n      Test\n      </a>\n      Other&')({
        message: 'Hi there!'
      })).toEqual('<body>\n  <script type="text/javascript">\n    //<![CDATA[\n      $(document).ready(function() {\n        alert("Hi there!");\n      });\n    //]]>\n  </script>\n  <p>\n    Foo&#x000A; <pre>Bar\nBaz</pre>&#x000A; <a>Test&#x000A; Test&#x000A; </a>&#x000A; Other\n    Foo\n    &lt;pre&gt;&#39;Bar&#39;\nBaz&lt;/pre&gt;\n    &lt;a&gt;Test\n    Test\n    &lt;/a&gt;\n    Other&amp;\n  </p>\n</body>\n');
    });
    it('should support interpolation in coffeescript', function() {
      return expect(haml.compileCoffeeHamlFromString('- h = (word) -> word.toLowerCase()\n%p\n  Look at \\\\#{h @word } lack of backslash: \\#{foo}\n  And yon presence thereof: \\{foo}').call({
        word: 'YON'
      })).toEqual('<p>\n  Look at \\\\yon lack of backslash: #{foo}\n  And yon presence thereof: \\{foo}\n</p>\n');
    });
    return it('generates filter blocks correctly with embedded coffeescript', function() {
      return expect(haml.compileCoffeeHamlFromString('%body\n  :javascript\n    $(document).ready(function() {\n      alert("#{@message}");\n    });\n  %p\n    :preserve\n      Foo\n      #{"<pre>Bar\\nBaz</pre>"}\n      <a>Test\n      Test\n      </a>\n      Other\n    :escaped\n      Foo\n      #{"<pre>\'Bar\'\\nBaz</pre>"}\n      <a>Test\n      Test\n      </a>\n      Other&').call({
        message: 'Hi there!'
      })).toEqual('<body>\n  <script type="text/javascript">\n    //<![CDATA[\n      $(document).ready(function() {\n        alert("Hi there!");\n      });\n    //]]>\n  </script>\n  <p>\n    Foo&#x000A; <pre>Bar\nBaz</pre>&#x000A; <a>Test&#x000A; Test&#x000A; </a>&#x000A; Other\n    Foo\n    &lt;pre&gt;&#39;Bar&#39;\nBaz&lt;/pre&gt;\n    &lt;a&gt;Test\n    Test\n    &lt;/a&gt;\n    Other&amp;\n  </p>\n</body>\n');
    });
  });

  describe('haml apis', function() {
    return describe('compileHaml', function() {
      var coffeeSource, hamlFixture, result;
      hamlFixture = '%h1\n' + '  %div\n' + '    %p This is "some" text\n' + '      This is #{"some"} text\n' + '    This is some <div> text\n' + '    \\%span\n' + '    %span %h1 %h1 %h1\n';
      result = '<h1>\n  <div>\n    <p>\n      This is "some" text\n      This is some text\n    </p>\n    This is some <div> text\n    %span\n    <span>\n      %h1 %h1 %h1\n    </span>\n  </div>\n</h1>\n';
      coffeeSource = 'function (context) {\nhandleError = haml.HamlRuntime._raiseError\nhtml = []\nhtml.push(\'<h1>\\n  <div>\\n    <p>\\n      This is \\"some\\" text\\n\')\nhtml.push("      This is #{"some"} text")\nhtml.push(\'\\n    </p>\\n    This is some <div> text\\n    %span\\n    <span>\\n      %h1 %h1 %h1\\n    </span>\\n  </div>\\n</h1>\\n\')\nreturn html.join("")\n}\n';
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="simple">\n' + hamlFixture + '</script>');
      });
      it('should take a source parameter', function() {
        return expect(haml.compileHaml({
          source: hamlFixture
        })()).toEqual(haml.compileStringToJs(hamlFixture)());
      });
      it('should take a sourceId parameter', function() {
        return expect(haml.compileHaml({
          sourceId: 'simple'
        })()).toEqual(haml.compileHaml('simple')());
      });
      it('should take a sourceUrl parameter', function() {
        spyOn(jQuery, 'ajax').andCallFake(function(params) {
          return params.success(hamlFixture);
        });
        return expect(haml.compileHaml({
          sourceUrl: 'http://localhost:8080/clientside-haml-js/spec/fixture.haml'
        })()).toEqual(result);
      });
      it('should take a outputFormat parameter', function() {
        expect(haml.compileHaml({
          source: hamlFixture,
          outputFormat: 'string'
        })).toEqual(haml.compileHamlToJsString(hamlFixture));
        return expect(typeof haml.compileHaml({
          source: hamlFixture,
          outputFormat: 'function'
        })).toEqual('function');
      });
      return it('should take a generator parameter', function() {
        expect(haml.compileHaml({
          source: hamlFixture,
          generator: 'javascript',
          outputFormat: 'string'
        })).toEqual(haml.compileHamlToJsString(hamlFixture));
        return expect(haml.compileHaml({
          source: hamlFixture,
          generator: 'coffeescript',
          outputFormat: 'string'
        })).toEqual(coffeeSource);
      });
    });
  });

  describe('haml issues', function() {
    describe('Issue #2 - Anonymous functions should pass through \'this\'', function() {
      var generator, i, len, ref, results;
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="anonymous">\n' + '.test = this.fnOnThis()\n' + '.test2 = fnOnThis()\n' + '</script>');
      });
      ref = ['javascript', 'productionjavascript'];
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        generator = ref[i];
        results.push((function(generator) {
          return it('should the correct html for ' + generator, function() {
            var context, html, that;
            that = {
              fnOnThis: function() {
                return 'TEST';
              }
            };
            context = {
              fnOnThis: function() {
                return 'TEST2';
              }
            };
            html = haml.compileHaml({
              sourceId: 'anonymous',
              generator: generator
            }).call(that, context);
            return expect(html).toEqual('\n<div class="test">\n' + '  TEST\n' + '</div>\n' + '<div class="test2">\n' + '  TEST2\n' + '</div>\n');
          });
        })(generator));
      }
      return results;
    });
    describe('Issue #6 - Empty lines should be ignored', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="empty-lines">\n' + '%div\n' + '  %div\n' + '    %div\n' + '    \n' + '    %div\n' + '  \n' + '    %div' + '\n' + '    %div' + '</script>');
      });
      return it('should render the correct html', function() {
        var html;
        html = haml.compileHaml('empty-lines')();
        return expect(html).toEqual('\n<div>\n' + '  <div>\n' + '    <div>\n' + '    \n' + '    </div>\n' + '    <div>\n' + '  \n' + '    </div>\n' + '    <div>\n' + '    </div>\n' + '    <div>\n' + '    </div>\n' + '  </div>\n' + '</div>\n');
      });
    });
    describe('Issue #14 - rendering null values', function() {
      var generator, i, len, ref, results;
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="null-js-values">\n' + '.inline-null\n' + '  = null;\n' + '.null-evaluating\n' + '  = nullValue;\n' + '.embedded-null= null\n' + '</script>');
      });
      ref = ['javascript', 'productionjavascript'];
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        generator = ref[i];
        results.push((function(generator) {
          return it('should render null values as a string for ' + generator, function() {
            var html;
            html = haml.compileHaml({
              sourceId: 'null-js-values',
              generator: generator
            })({
              nullValue: null
            });
            return expect(html).toEqual('\n<div class="inline-null">\n' + '  \n' + '</div>\n' + '<div class="null-evaluating">\n' + '  \n' + '</div>\n' + '<div class="embedded-null">\n' + '  \n' + '</div>\n');
          });
        })(generator));
      }
      return results;
    });
    describe('Issue 13 - comments', function() {
      beforeEach(function() {
        return setFixtures('<script type="text/template" id="comment-issue">\n' + '#div1\n' + '  -# if blahDiBlah\n' + '    #shouldNotRender\n' + '      .shouldAlsoNotRender\n' + '        You should not see me\n' + '  You should see me\n' + '-# #div2\n' + '  I\'m Invisible!\n' + '#div3\n' + '  You should see me\n' + '</script>');
      });
      return it('should render the correct html', function() {
        var html;
        html = haml.compileHaml('comment-issue')();
        return expect(html).toEqual('\n<div id="div1">\n' + '  You should see me\n' + '</div>\n' + '<div id="div3">\n' + '  You should see me\n' + '</div>\n');
      });
    });
    describe('Issue #21 - text node followed by tag node fails', function() {
      var hex;
      hex = function(str) {
        return _((_.str || _).chars(str)).map(function(ch) {
          return (_.str || _).pad(ch.charCodeAt(0).toString(16), 2, '0');
        }).join('');
      };
      it('should no fail to generate a js function due to newlines', function() {
        var html;
        setFixtures('<script type="text/template" id="issue-21">\n%div\ntext\n%p 123\n</script>');
        html = haml.compileHaml({
          sourceId: 'issue-21'
        })();
        return expect(html).toEqual('\n<div>\n</div>\ntext\n<p>\n  123\n</p>\n');
      });
      it("should handle Unix line endings", function() {
        var html, source;
        source = "\u000A%div\u000Atext\u000A%p 123\u000A";
        html = haml.compileHaml({
          source: source
        })();
        return expect(html).toEqual("\n<div>\n</div>\ntext\n<p>\n  123\n</p>\n");
      });
      it("should handle Windows line endings", function() {
        var html, source;
        source = "\u000D\u000A%div\u000D\u000Atext\u000D\u000A%p 123\u000D\u000A";
        html = haml.compileHaml({
          source: source
        })();
        return expect(hex(html)).toEqual(hex("\r\n<div>\n</div>\ntext\r\n<p>\n  123\r\n</p>\n"));
      });
      return it("should handle endings in any order", function() {
        var html, source;
        source = "\u000D\u000A%div\u000A\u000Dtext\u000D%p 123\u000D\u000A";
        html = haml.compileHaml({
          source: source
        })();
        return expect(hex(html)).toEqual(hex("\r\n<div>\n</div>\n\rtext\r%p 123\r\n"));
      });
    });
    describe('Issue #24 - inconsistent indent handling', function() {
      it('should handle indentation modulo 2', function() {
        var expected, html;
        expected = '<table>\n  <tr>\n  </tr>\n</table>\n';
        html = haml.compileHaml({
          source: '%table\n\t%tr'
        })();
        expect(html).toEqual(expected);
        html = haml.compileHaml({
          source: '%table\n %tr'
        })();
        expect(html).toEqual(expected);
        html = haml.compileHaml({
          source: '%table\n  %tr'
        })();
        return expect(html).toEqual(expected);
      });
      return it('should count tabs as 2 characters', function() {
        var expected, html;
        expected = '<table>\n  <tr>\n    <td>\n    </td>\n  </tr>\n</table>\n';
        html = haml.compileHaml({
          source: '%table\n\t%tr\n\t\t%td'
        })();
        return expect(html).toEqual(expected);
      });
    });
    describe('Issue #25 - Incorrect coffeescript indentation', function() {
      return it('should indent the lines within logic blocks correctly', function() {
        var expected, hamlSource;
        hamlSource = '-if true\n  %a{href : \'#new\'} create new';
        expected = '<a href="#new">\n    create new\n  </a>';
        return expect(_.str.trim(haml.compileHaml({
          source: hamlSource,
          generator: 'coffeescript'
        })())).toEqual(expected);
      });
    });
    describe('Issue #27 - multiple levels of nesting confuses haml parser', function() {
      return it('should indent the lines within logic blocks correctly', function() {
        var expected, hamlSource, players;
        hamlSource = '%ul{"class":"nav nav-tabs"}\n  - for player in @players\n    %li\n      %a{\'href\':"#player#{player.id}", "data-toggle":"tab"}\n        = player.get("name")';
        expected = '<ul class="nav nav-tabs">\n    <li>\n      <a href="#player1" data-toggle="tab">\n        travis\n      </a>\n    </li>\n</ul>';
        players = [
          {
            id: 1,
            name: 'travis',
            get: function(attr) {
              return this.name;
            }
          }
        ];
        return expect(_.str.trim(haml.compileHaml({
          source: hamlSource,
          generator: 'coffeescript'
        }).call({
          players: players
        }))).toEqual(expected);
      });
    });
    describe('Issue #30 - if/else statements don\'t work for embedded coffeescript', function() {
      return it('should be able to handle else statements', function() {
        var expected, hamlSource, options;
        hamlSource = '-for option in @options\n  - if option.value == @selected\n    = option.text\n  - else\n    .unselected\n      = option.text';
        expected = 'text 1\n    <div class="unselected">\n      text 2\n    </div>\n    <div class="unselected">\n      text 3\n    </div>';
        options = [
          {
            value: '1',
            text: 'text 1'
          }, {
            value: '2',
            text: 'text 2'
          }, {
            value: '3',
            text: 'text 3'
          }
        ];
        return expect(_.str.trim(haml.compileHaml({
          source: hamlSource,
          generator: 'coffeescript'
        }).call({
          options: options,
          selected: '1'
        }))).toEqual(expected);
      });
    });
    it('should be able to handle else statements with extra ifs', function() {
      var expected, hamlSource, options;
      hamlSource = '-for option in @options\n  - if option.value == @selected\n    = option.text\n    - if false\n      false\n    - else\n      true\n  - else\n    .unselected\n      = option.text';
      expected = 'text 1\n      true\n    <div class="unselected">\n      text 2\n    </div>\n    <div class="unselected">\n      text 3\n    </div>';
      options = [
        {
          value: '1',
          text: 'text 1'
        }, {
          value: '2',
          text: 'text 2'
        }, {
          value: '3',
          text: 'text 3'
        }
      ];
      return expect(_.str.trim(haml.compileHaml({
        source: hamlSource,
        generator: 'coffeescript'
      }).call({
        options: options,
        selected: '1'
      }))).toEqual(expected);
    });
    describe('Issue #29 - backslash when escaping ampersand character appears in DOM', function() {
      return it('should not be excluding the bashslashed character', function() {
        var expected, hamlSource;
        hamlSource = '%p\n  \\&copy; Company 2012';
        expected = '<p>\n  &copy; Company 2012\n</p>';
        return expect(_.str.trim(haml.compileHaml({
          source: hamlSource
        })())).toEqual(expected);
      });
    });
    describe('Issue #31 - new line in eval breaking generated function', function() {
      return it('should not blow up', function() {
        var data, expected, hamlSource;
        hamlSource = '%div{class: \'hero-unit\'}\n  %h2= email.subject\n  %iframe{class: \'email-preview\', src: iframeSource}';
        expected = '<div class="hero-unit">\n  <h2>\n    Issue #31\n  </h2>\n  <iframe class="email-preview" src="blahblahblah">\n  </iframe>\n</div>';
        data = {
          email: {
            subject: 'Issue #31'
          },
          iframeSource: 'blahblahblah'
        };
        return expect(_.str.trim(haml.compileHaml({
          source: hamlSource
        })(data))).toEqual(expected);
      });
    });
    describe('Issue #34 - Haml does not format attributes which are 3 or more layers deep correctly', function() {
      return it('should handle nested hashes correctly', function() {
        expect(_.str.trim(haml.compileHaml({
          source: '%a{data:{theme:{test:"A"}}}<'
        })())).toEqual('<a data-theme-test="A"></a>');
        return expect(_.str.trim(haml.compileHaml({
          source: '.foo{data: {a: "b", c: {d: "e", f: "g"}}}<'
        })())).toEqual('<div class="foo" data-a="b" data-c-d="e" data-c-f="g"></div>');
      });
    });
    describe('Issue #37 - Unexpected behavior', function() {
      return it('should render correctly', function() {
        var data, expected, hamlSource;
        hamlSource = '.content Hello World!\n\n%div{class:"hi"}\n  = hello\n\n%span[obj1]\n  wtf?';
        expected = '<div class="content">\nHello World!\n\n</div>\n<div class="hi">\n  I&#39;m a variable!\n\n</div>\n<span id="object-1" class="test">\n  wtf?\n</span>';
        data = {
          hello: "I'm a variable!",
          obj1: {
            id: "object-1",
            "class": "test"
          }
        };
        return expect(_.str.trim(haml.compileHaml({
          source: hamlSource
        })(data))).toEqual(expected);
      });
    });
    return describe('Issue #38 - Whitespace not calculated correctly when only using tabs for indentation', function() {
      return it('should calculate indentation with tabs correctly', function() {
        var expected, hamlSource;
        hamlSource = ".page\n\t.row\n\t\t%section\n\t\t\t%h5 header\n\t\t\t%p\n\t\t\t\t%span foobar";
        expected = '<div class="page">\n  <div class="row">\n    <section>\n      <h5>\n        header\n      </h5>\n      <p>\n        <span>\n          foobar\n        </span>\n      </p>\n    </section>\n  </div>\n</div>';
        return expect(_.str.trim(haml.compileHaml({
          source: hamlSource
        })())).toEqual(expected);
      });
    });
  });

  describe('haml runtime', function() {
    describe('flattening hashes', function() {
      describe('with no root key', function() {
        describe('with non-hashes', function() {
          return it('returns non-hash objects', function() {
            var date;
            expect(haml.HamlRuntime._flattenHash(null, null)).toEqual(null);
            expect(haml.HamlRuntime._flattenHash(null, 'string')).toEqual('string');
            expect(haml.HamlRuntime._flattenHash(null, true)).toEqual(true);
            date = new Date();
            expect(haml.HamlRuntime._flattenHash(null, date)).toEqual(date);
            return expect(haml.HamlRuntime._flattenHash(null, [1, 2, 3, 4])).toEqual([1, 2, 3, 4]);
          });
        });
        return describe('with hashes', function() {
          return it('expands the values of the hash', function() {
            return expect(haml.HamlRuntime._flattenHash(null, {
              a: 'a',
              b: true,
              c: [1, 2, 3],
              d: {
                a: 'a',
                b: 'b'
              }
            })).toEqual({
              a: 'a',
              b: true,
              c: [1, 2, 3],
              'd-a': 'a',
              'd-b': 'b'
            });
          });
        });
      });
      return describe('with a root key', function() {
        describe('with non-hashes', function() {
          return it('returns a hash with the key set to the passed object', function() {
            var date;
            expect(haml.HamlRuntime._flattenHash('a', null)).toEqual({
              a: null
            });
            expect(haml.HamlRuntime._flattenHash('b', 'string')).toEqual({
              b: 'string'
            });
            expect(haml.HamlRuntime._flattenHash('c', true)).toEqual({
              c: true
            });
            date = new Date();
            expect(haml.HamlRuntime._flattenHash('d', date)).toEqual({
              d: date
            });
            return expect(haml.HamlRuntime._flattenHash('e', [1, 2, 3, 4])).toEqual({
              e: [1, 2, 3, 4]
            });
          });
        });
        return describe('with hashes', function() {
          return it('expands the values of the hash adding the root key to all keys', function() {
            return expect(haml.HamlRuntime._flattenHash('t', {
              a: 'a',
              b: true,
              c: [1, 2, 3],
              d: {
                a: 'a',
                b: 'b'
              }
            })).toEqual({
              't-a': 'a',
              't-b': true,
              't-c': [1, 2, 3],
              't-d-a': 'a',
              't-d-b': 'b'
            });
          });
        });
      });
    });
    return describe('detecting hashes', function() {
      it('detects hashes', function() {
        expect(haml.HamlRuntime._isHash({})).toBeTruthy();
        return expect(haml.HamlRuntime._isHash({
          'a': 'b'
        })).toBeTruthy();
      });
      it('ignores arrays', function() {
        expect(haml.HamlRuntime._isHash([])).toBeFalsy();
        return expect(haml.HamlRuntime._isHash([1, 2, 3, 4])).toBeFalsy();
      });
      it('ignores null', function() {
        return expect(haml.HamlRuntime._isHash(null)).toBeFalsy();
      });
      it('ignores strings', function() {
        return expect(haml.HamlRuntime._isHash('')).toBeFalsy();
      });
      it('ignores numbers', function() {
        return expect(haml.HamlRuntime._isHash(1)).toBeFalsy();
      });
      it('ignores functions', function() {
        return expect(haml.HamlRuntime._isHash(function() {})).toBeFalsy();
      });
      it('ignores dates', function() {
        return expect(haml.HamlRuntime._isHash(new Date())).toBeFalsy();
      });
      return it('ignores booleans', function() {
        return expect(haml.HamlRuntime._isHash(true)).toBeFalsy();
      });
    });
  });

  describe('buffer', function() {
    return describe('trimming whitespace', function() {
      beforeEach(function() {
        return this.buffer = new haml.Buffer(null);
      });
      it('trims the whitespace from the end of the string', function() {
        this.buffer.append("some text to trim \t\n");
        this.buffer.trimWhitespace();
        return expect(this.buffer.buffer).toEqual("some text to trim");
      });
      it('trims down to the empty string', function() {
        this.buffer.append("     \t\n  ");
        this.buffer.trimWhitespace();
        return expect(this.buffer.buffer).toEqual("");
      });
      return it('does not blow away single characters in the buffer', function() {
        this.buffer.append(">");
        this.buffer.trimWhitespace();
        return expect(this.buffer.buffer).toEqual(">");
      });
    });
  });

  describe('code generators', function() {
    describe('with fault tolerance off', function() {
      return describe('javascript generate', function() {
        return it('will raise an exception on error', function() {
          return expect(function() {
            return haml.compileHaml({
              source: '.test= null.toString()'
            })();
          }).toThrow();
        });
      });
    });
    return describe('with fault tolerance on', function() {
      return describe('javascript generate', function() {
        return it('will not raise an exception on error', function() {
          return expect(function() {
            return haml.compileHaml({
              source: '.test= null.toString()',
              tolerateFaults: true
            })();
          }).not.toThrow();
        });
      });
    });
  });

  describe('error handling', function() {
    describe('with an js runtime error', function() {
      beforeEach(function() {
        return this.haml = '.value>< = null.toString()';
      });
      it('raises an exception in normal mode', function() {
        return expect((function(_this) {
          return function() {
            return haml.compileHaml({
              source: _this.haml
            })();
          };
        })(this)).toThrow();
      });
      return it('does not raise an exception in fault tolerant mode', function() {
        expect((function(_this) {
          return function() {
            return _this.result = haml.compileHaml({
              source: _this.haml,
              tolerateFaults: true
            })();
          };
        })(this)).not.toThrow();
        return expect(this.result).toBe('<div class="value"></div>');
      });
    });
    describe('with an error in the attribute hash', function() {
      beforeEach(function() {
        return this.haml = '.value{this is not a hash}><';
      });
      it('raises an exception in normal mode', function() {
        return expect((function(_this) {
          return function() {
            return haml.compileHaml({
              source: _this.haml
            })();
          };
        })(this)).toThrow();
      });
      return it('does not raise an exception in fault tolerant mode', function() {
        expect((function(_this) {
          return function() {
            return _this.result = haml.compileHaml({
              source: _this.haml,
              tolerateFaults: true
            })();
          };
        })(this)).not.toThrow();
        return expect(this.result).toBe('<div class="value"></div>');
      });
    });
    describe('with an unknown filter', function() {
      beforeEach(function() {
        return this.haml = '.p><\n  :unknown\n    this is not the filter you where looking for\n  test';
      });
      it('raises an exception in normal mode', function() {
        return expect((function(_this) {
          return function() {
            return haml.compileHaml({
              source: _this.haml
            })();
          };
        })(this)).toThrow();
      });
      return it('does not raise an exception in fault tolerant mode', function() {
        expect((function(_this) {
          return function() {
            return _this.result = haml.compileHaml({
              source: _this.haml,
              tolerateFaults: true
            })();
          };
        })(this)).not.toThrow();
        return expect(this.result).toBe('<div class="p">test</div>');
      });
    });
    describe('with an self-closing tag with content', function() {
      beforeEach(function() {
        return this.haml = '.p/ test';
      });
      it('raises an exception in normal mode', function() {
        return expect((function(_this) {
          return function() {
            return haml.compileHaml({
              source: _this.haml
            })();
          };
        })(this)).toThrow();
      });
      return it('does not raise an exception in fault tolerant mode', function() {
        expect((function(_this) {
          return function() {
            return _this.result = haml.compileHaml({
              source: _this.haml,
              tolerateFaults: true
            })();
          };
        })(this)).not.toThrow();
        return expect(this.result).toBe('<div class="p"/>\ntest\n');
      });
    });
    describe('with no closing attribute list', function() {
      beforeEach(function() {
        return this.haml = '.p(a="b"';
      });
      it('raises an exception in normal mode', function() {
        return expect((function(_this) {
          return function() {
            return haml.compileHaml({
              source: _this.haml
            })();
          };
        })(this)).toThrow();
      });
      return it('does not raise an exception in fault tolerant mode', function() {
        expect((function(_this) {
          return function() {
            return _this.result = haml.compileHaml({
              source: _this.haml,
              tolerateFaults: true
            })();
          };
        })(this)).not.toThrow();
        return expect(this.result).toBe('<div class="p" a="b">\n</div>\n');
      });
    });
    describe('with an invalid attribute list', function() {
      beforeEach(function() {
        return this.haml = '.p(a="b" =)';
      });
      it('raises an exception in normal mode', function() {
        return expect((function(_this) {
          return function() {
            return haml.compileHaml({
              source: _this.haml
            })();
          };
        })(this)).toThrow();
      });
      return it('does not raise an exception in fault tolerant mode', function() {
        expect((function(_this) {
          return function() {
            return _this.result = haml.compileHaml({
              source: _this.haml,
              tolerateFaults: true
            })();
          };
        })(this)).not.toThrow();
        return expect(_.str.trim(haml.compileHaml({
          source: this.haml,
          tolerateFaults: true
        })())).toEqual('<div class="p" a="b">\n  \n</div>');
      });
    });
    describe('with a missing closing bracket', function() {
      beforeEach(function() {
        return this.haml = '.p(a="b"\n  .o Something not seen\n.r(a="b")\n  You should see me\n.q\n  You should see me';
      });
      it('raises an exception in normal mode', function() {
        return expect((function(_this) {
          return function() {
            return haml.compileHaml({
              source: _this.haml
            })();
          };
        })(this)).toThrow();
      });
      return it('does not raise an exception in fault tolerant mode', function() {
        expect((function(_this) {
          return function() {
            return _this.result = haml.compileHaml({
              source: _this.haml,
              tolerateFaults: true
            })();
          };
        })(this)).not.toThrow();
        return expect(_.str.trim(haml.compileHaml({
          source: this.haml,
          tolerateFaults: true
        })())).toEqual('<div class="p" a="b">\n.o Something not seen\n</div>\n<div class="r" a="b">\n  You should see me\n</div>\n<div class="q">\n  You should see me\n</div>');
      });
    });
    return describe('with a missing closing brace', function() {
      beforeEach(function() {
        return this.haml = '.p{a: "b"\n  .o Something not seen\n.r{a: "b"}\n  You should see me\n.q\n  You should see me';
      });
      xit('raises an exception in normal mode', function() {
        return expect((function(_this) {
          return function() {
            return haml.compileHaml({
              source: _this.haml
            })();
          };
        })(this)).toThrow();
      });
      return xit('does not raise an exception in fault tolerant mode', function() {
        expect((function(_this) {
          return function() {
            return _this.result = haml.compileHaml({
              source: _this.haml,
              tolerateFaults: true
            })();
          };
        })(this)).not.toThrow();
        return expect(_.str.trim(haml.compileHaml({
          source: this.haml,
          tolerateFaults: true
        })())).toEqual('<div class="p" a="b">\n.o Something not seen\n</div>\n<div class="r" a="b">\n  You should see me\n</div>\n<div class="q">\n  You should see me\n</div>');
      });
    });
  });

}).call(this);

//# sourceMappingURL=haml-spec.js.map
